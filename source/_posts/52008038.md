---
title: <原>#  BestCoder Round #84 &&HDU 5750 Dertouzos 【数论+暴力】
date: 2016-07-23 23:14:02
description:
toc: true
author: tabris
# 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg
img: 
# 如果top值为true，则会是首页推荐文章
top: false
# 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破
password: 
# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行
mathjax: false
summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要
categories: OJ算法题
tags:

---




#  BestCoder Round #84 &&HDU 5750 Dertouzos 【数论+暴力】

2016年07月23日 23:14:02  [ Tabris_ ](https://me.csdn.net/qq_33184171) 阅读数：834


--- 
 博客爬取于`2019-04-18 17:20:20`
***以下为正文***

版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。
https://blog.csdn.net/qq_33184171/article/details/52008038

题目连接： [ http://acm.hdu.edu.cn/showproblem.php?pid=5750
](http://acm.hdu.edu.cn/showproblem.php?pid=5750)

—————————————–.

Dertouzos Accepts: 76 Submissions: 1357  
Time Limit: 7000/3500 MS (Java/Others) Memory Limit: 131072/131072 K
(Java/Others)  
问题描述  
正整数  x  称为  n  的positive proper divisor, 当且仅当  x  |  n  并且  1  ≤  x  < n  .
例如, 1, 2, 和3是6的positive proper divisor, 但是6不是.

Peter给你两个正整数  n  和  d  . 他想要知道有多少小于  n  的整数, 满足他们的最大positive proper divisor恰好是
d  .  
输入描述  
输入包含多组数据, 第一行包含一个整数  T  (  1  ≤  T  ≤  10  6  )  表示测试数据组数. 对于每组数据:

第一行包含两个整数  n  和  d  (  2  ≤  n  ,  d  ≤  10  9  )

输出描述  
对于每组数据, 输出一个整数.  
输入样例  
9  
10 2  
10 3  
10 4  
10 5  
10 6  
10 7  
10 8  
10 9  
100 13  
输出样例  
1  
2  
1  
0  
0  
0  
0  
0  
4

—————————————————-.

题目大意： 自己看

解题思路：  
首先要明确的是 N*M的最大因子为N的时候只有M为素数 且M<=N的最小素因子的时候 ；  
试想  N  =  p  a  1  1  ∗  p  a  2  2  ∗  p  a  3  3  ∗  p  a  4  4  ∗  …  …  ∗
p  a  n  n  ;  (  p  [  i  ]  < p  [  i  \+  1  ]  )  
如果M不是素数那么M=X*Y，N*M的因子中 就多了N*X和N*Y 均比N大 所以不成立  
如果M>p1 （假设所有的ai均为1）那么N*M的因子中 就多了  M  ∗  p  2  ∗  p  3  ∗  p  4  ∗  …  …  ∗  p
n  一定大于  p  1  ∗  p  2  ∗  p  3  ∗  p  4  ∗  …  …  ∗  p  n  所以也不成立 至于某个  a  i
> 1  的时候同理  
也不行

所以先打出sqrt(1e9)内的所有素数  
然后暴力找即可

    
    
       for(int i=0;i<k;i++)
        {
            if(d*prime[i]>=n)   break;
            sum++;
            if(d%prime[i]==0)   break;
        }

k值不到1e4 加上题目3500ms 就能过了

附上本题代码

———————————————————-.

    
    
    #include <iostream>
    #include <algorithm>
    #include <cmath>
    #include <cstdio>
    #include <cstring>
    using namespace std;
    
    #define LL __int64
    
    const LL MOD = 1e9+7;
    const LL INF = 0x3f3f3f3f;
    
    int Is_or[101010];
    int prime[10000];
    int k=0;
    
    void Prime()
    {
        memset(Is_or,1,sizeof(Is_or));
    
        int n=100000;
        for(int i=2;i<=n;i++)
            if(Is_or[i])
            {
                prime[k++]=i;
                for(int j=i+i;j<=n;j+=i)
                    Is_or[j]=0;
            }
    
        return ;
    }
    
    int primeproper(int num,int n)
    {
        int sum=0;
        for(int i=0;i<k;i++)
        {
            if(num*prime[i]>=n)   break;
            sum++;
            if(num%prime[i]==0)   break;
        }
        return sum;
    }
    
    int main()
    {
        Prime();
        printf("%d  %d  ",prime[k-1],prime[4229]);
        printf("%d\n",k);
        int t;
        scanf("%d",&t);
        while(t--)
        {
            int n,m;
            scanf("%d%d",&n,&m);
    
            int d = primeproper(m,n);
    
            printf("%d\n",d);
    
        }
        return 0;
    }
    
    

