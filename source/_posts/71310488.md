---
title: <原>#  CSUOJ 1503 点到圆弧的距离 [叉积+三角形外心]【计算几何】
date: 2017-05-07 11:24:54
description:
toc: true
author: tabris
# 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg
img: 
# 如果top值为true，则会是首页推荐文章
top: false
# 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破
password: 
# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行
mathjax: false
summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要
categories: OJ算法题
tags:

---




#  CSUOJ 1503: 点到圆弧的距离 [叉积+三角形外心]【计算几何】

2017年05月07日 11:24:54  [ Tabris_ ](https://me.csdn.net/qq_33184171) 阅读数：617

---
 博客爬取于`2019-04-18 17:16:53`
***以下为正文***

版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。
https://blog.csdn.net/qq_33184171/article/details/71310488

题目链接： [ http://acm.csu.edu.cn/csuoj/problemset/problem?pid=1503
](http://acm.csu.edu.cn/csuoj/problemset/problem?pid=1503)  
————————————————————————————————————————————  
1503: 点到圆弧的距离  
Submit Page Summary Time Limit: 1 Sec Memory Limit: 128 Mb Submitted: 850
Solved: 221 SpecialJudge  
Description  
输入一个点P和一条圆弧（圆周的一部分），你的任务是计算P到圆弧的最短距离。换句话说，你需要在圆弧上找一个点，到P点的距离最小。  
提示：请尽量使用精确算法。相比之下，近似算法更难通过本题的数据。

Input  
输入包含最多10000组数据。每组数据包含8个整数x1, y1, x2, y2, x3, y3, xp,
yp。圆弧的起点是A(x1,y1)，经过点B(x2,y2)，结束位置是C(x3,y3)。点P的位置是 (xp,yp)。输入保证A, B,
C各不相同且不会共线。上述所有点的坐标绝对值不超过20。

Output  
对于每组数据，输出测试点编号和P到圆弧的距离，保留三位小数。你的输出和标准输出之间最多能有0.001的误差。

Sample Input  
0 0 1 1 2 0 1 -1  
3 4 0 5 -3 4 0 1  
Sample Output  
Case 1: 1.414  
Case 2: 4.000  
Hint  
Source  
湖南省第十届大学生计算机程序设计竞赛

————————————————————————————————————————————

首先能确定的是,在圆弧所在的扇形的角内的点,最近距离是 ` dis(p,r) ` ,否则是 ` min(dis(p,a),dis(p,c)) ` .

所以就是如何确定在不在扇形所在的角内了 扇形所在的角如下图所示

![这里写图片描述](https://img-blog.csdn.net/20170507110706524?watermark/2/text/aHR0cD
ovL2Jsb2cuY3Nkbi5uZXQvcXFfMzMxODQxNzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkF
CMA==/dissolve/70/gravity/SouthEast)

分为劣弧和优弧,

在判断上要有所不同,  
![这里写图片描述](https://img-blog.csdn.net/20170507111743232?watermark/2/text/aHR0cD
ovL2Jsb2cuY3Nkbi5uZXQvcXFfMzMxODQxNzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkF
CMA==/dissolve/70/gravity/SouthEast)

  * 劣弧   
劣弧的时候很好判定这里运用了向量叉积的判定方法,只要  r  a  −  →  和  r  p  →  在  r  c  →  的  同  一  侧  且
r  c  →  和  r  p  →  在  r  a  −  →  的  同  一  侧  就能保证了,

  * 优弧   
优弧的时候麻烦一些,对于p’ 可以和劣弧相同,不赘述  
对于p和p”却要不一样, 首先我们只要b可以再弧上的任意位置,以b为参考点是不行的.  
但其实仔细观察  ∠  a  r  c  和点p” 其实发现这就是反过来的劣弧的情况,所以在判断是优弧的情况下来重复劣弧的过程就行了,

那么就只剩下怎么判断优劣弧,  
其实只要判断  ∠  a  b  c  的角度就好了 大于90度就是劣弧,小于90度就是优弧,(不解释)  
为了方便计算我们转化为余弦公式计算,判断正负就好了

附本题代码  
————————————————————————————————————————————


​    
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long int LL ;
    const int N = 1000+7;
    const int MOD = 1000000007;
    #define abs(x)  (((x)>0)?(x):-(x))
    
    /***************************************/
    
    struct point{
        double x,y;
    }a,b,c,r,p;
    
    double dis(point a,point b){
        return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
    }
    
    double dis2(point a,point b){
        return ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
    }
    
    double mutli(point p1,point p2,point p3){
        return ((p2.x-p1.x)*(p3.y-p1.y) - (p2.y-p1.y)*(p3.x-p1.x));
    }
    
    point solvepointR(){
        double  x1,x2,x3,y1,y2,y3;
    
        x1=a.x,y1=a.y;
        x2=b.x,y2=b.y;
        x3=c.x,y3=c.y;
    
        point t;
        t.x=((y2-y1)*(y3*y3-y1*y1+x3*x3-x1*x1)-(y3-y1)*(y2*y2-y1*y1+x2*x2-x1*x1))/(2*(x3-x1)*(y2-y1)-2*((x2-x1)*(y3-y1)));
        t.y=((x2-x1)*(x3*x3-x1*x1+y3*y3-y1*y1)-(x3-x1)*(x2*x2-x1*x1+y2*y2-y1*y1))/(2*(y3-y1)*(x2-x1)-2*((y2-y1)*(x3-x1)));
    
        return t;
    }
    
    int Main(){
        int kcase = 0;
        while(~scanf("%lf%lf",&a.x,&a.y)){
            scanf("%lf%lf",&b.x,&b.y);
            scanf("%lf%lf",&c.x,&c.y);
            scanf("%lf%lf",&p.x,&p.y);
    
            r = solvepointR();
    //        printf("R : %lf %lf\n",r.x,r.y);
            double R = dis(r,a);
    
            double pa = dis(p,a),pc = dis(p,c),pcir=fabs(dis(p,r)-R);
    //        printf("%lf %lf %lf\n",pa,pc,pcir);
            double ans = min(pa,pc);
            if(mutli(r,c,p)*mutli(r,c,b)>=0 && mutli(r,a,p)*mutli(r,a,b)>=0)
                ans = pcir;
    
            if( (dis2(a,b)+dis2(b,c)-dis2(a,c))/(2*dis(a,b)*dis(b,c)) >=0 ){
                if(mutli(r,c,p)*mutli(r,c,a)<0 || mutli(r,a,p)*mutli(r,a,c)<0){
    //                puts("----");
                    ans = pcir;
                }
            }
    
            printf("Case %d: %.3f\n",++kcase,ans);
        }
        return 0;
    }


