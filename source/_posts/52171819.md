---
title: <原>#  codeforces 704A Thor [技巧吧.]
date: 2016-08-10 15:19:05
description:
toc: true
author: tabris
# 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpg
img: 
# 如果top值为true，则会是首页推荐文章
top: false
# 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破
password: 
# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行
mathjax: false
summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要
categories: OJ算法题
tags:

---




#  codeforces 704A Thor [技巧吧.]

2016年08月10日 15:19:05  [ Tabris_ ](https://me.csdn.net/qq_33184171) 阅读数：440


--- 
 博客爬取于`2019-04-18 17:20:09`
***以下为正文***

版权声明：本文为Tabris原创文章，未经博主允许不得私自转载。
https://blog.csdn.net/qq_33184171/article/details/52171819

题目连接 : [ http://codeforces.com/problemset/problem/704/A
](http://codeforces.com/problemset/problem/704/A)

————————————–.  
A. Thor  
time limit per test2 seconds  
memory limit per test256 megabytes  
inputstandard input  
outputstandard output  
Thor is getting used to the Earth. As a gift Loki gave him a smartphone. There
are n applications on this phone. Thor is fascinated by this phone. He has
only one minor issue: he can’t count the number of unread notifications
generated by those applications (maybe Loki put a curse on it so he can’t).

q events are about to happen (in chronological order). They are of three
types:

Application x generates a notification (this new notification is unread).  
Thor reads all notifications generated so far by application x (he may re-read
some notifications).  
Thor reads the first t notifications generated by phone applications
(notifications generated in first t events of the first type). It’s guaranteed
that there were at least t events of the first type before this event. Please
note that he doesn’t read first t unread notifications, he just reads the very
first t notifications generated on his phone and he may re-read some of them
in this operation.  
Please help Thor and tell him the number of unread notifications after each
event. You may assume that initially there are no notifications in the phone.

Input  
The first line of input contains two integers n and q (1 ≤ n, q ≤ 300 000) —
the number of applications and the number of events to happen.

The next q lines contain the events. The i-th of these lines starts with an
integer typei — type of the i-th event. If typei = 1 or typei = 2 then it is
followed by an integer xi. Otherwise it is followed by an integer ti (1 ≤
typei ≤ 3, 1 ≤ xi ≤ n, 1 ≤ ti ≤ q).

Output  
Print the number of unread notifications after each event.

Examples  
input  
3 4  
1 3  
1 1  
1 2  
2 3  
output  
1  
2  
3  
2  
input  
4 6  
1 2  
1 4  
1 2  
3 3  
1 3  
1 3  
output  
1  
2  
3  
0  
1  
2  
Note  
In the first sample:

Application 3 generates a notification (there is 1 unread notification).  
Application 1 generates a notification (there are 2 unread notifications).  
Application 2 generates a notification (there are 3 unread notifications).  
Thor reads the notification generated by application 3, there are 2 unread
notifications left.  
In the second sample test:

Application 2 generates a notification (there is 1 unread notification).  
Application 4 generates a notification (there are 2 unread notifications).  
Application 2 generates a notification (there are 3 unread notifications).  
Thor reads first three notifications and since there are only three of them so
far, there will be no unread notification left.  
Application 3 generates a notification (there is 1 unread notification).  
Application 3 generates a notification (there are 2 unread notifications).

———————————-.  
题目大意 :  
就是你有一个手机 有三种操作  
1,x软件收到一个信息  
2,看了所有x软件的信息  
3,看了第1~第x次收到的信息 （被看过的也算）

每次都输出一下当前手机里的未读信息的个数

题解 ：  
首先把信息编号  
用一个vector 和set 维护下就好了  
vector有n个 代表n个软件 每次向n[x]中加入新的信息编号  
set存储所有的信息

维护的时候  
对于1 操作 把信息编号加入vector 和set  
对于2 操作 对应n[x]遍历一遍 从set中删除  
对于3 操作 遍历1~x 从set中删除 （这里注意每次的x要记录一下 然后下一次遍历的时候只要遍历这个x到下一个x的区间就行了 之前被删除的不用再删除一遍
否则会TLE）  
每次输出set的大小就行了

这样总体复杂度是O(2n)

/ ** _ ** ****** ** _ ** 这些shi牢骚  
这道题是赛后补得 并且看了网上的题解  
当时 想到了思路 当时没有做主要是怕TLE 在一个不太会用set （我是小白） 当时想到的是对数组二分查找整个区间 然后删除
当对判断数据的统计这一块只想到了线段树（赛前几天才学习数据结构，做什么题都想用线段树） 然后旁边队友 风骚的A了这道题后 告诉用STL做
然而对于不会STL的我老说 根本没法搞。 So我就不做了。。。  
仔细想来 根本不用那么麻烦 多熟练下vector map set 这东西其实是能秒的。。  
** _ ** ****** ** _ ** /   
附本题代码  
————————-.

    
    
    #include<bits/stdc++.h>
    using namespace std;
    
    typedef long long ll;
    const int maxn = 300010;
    
    vector<int> app[maxn];
    set<int> cnt;
    
    int main()
    {
        int n,q,x,type,num;
        while(~scanf("%d%d",&n,&q))
        {
            num = 0;
            cnt.clear();
            int last = 0;
            for(int i=0;i<q;i++)
            {
                scanf("%d%d",&type,&x);
                if(type==1)
                {
                    app[x].push_back(++num);
                    cnt.insert(num);
                }
                else if(type==2)
                {
                    for(int i=0;i<app[x].size();i++)
                        cnt.erase(app[x][i]);
                    app[x].clear();
                }
                else
                {
                    for(int i=last;i<=x;i++)
                    {
                        cnt.erase(i);
                    }
                    last = max(x,last);
                }
                printf("%d\n",cnt.size());
            }
        }
        return 0;
    }

